// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sea.proto

#ifndef PROTOBUF_sea_2eproto_INCLUDED
#define PROTOBUF_sea_2eproto_INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include "common.pb.h"
#include "user.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_sea_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[13];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsGetPiCodeRequestImpl();
void InitDefaultsGetPiCodeRequest();
void InitDefaultsGetPiCodeReplyImpl();
void InitDefaultsGetPiCodeReply();
void InitDefaultsGetSmsVericodeRequestImpl();
void InitDefaultsGetSmsVericodeRequest();
void InitDefaultsGetSmsVericodeReplyImpl();
void InitDefaultsGetSmsVericodeReply();
void InitDefaultsSignupRequestImpl();
void InitDefaultsSignupRequest();
void InitDefaultsSignupReplyImpl();
void InitDefaultsSignupReply();
void InitDefaultsSetUserBasicInfoRequestImpl();
void InitDefaultsSetUserBasicInfoRequest();
void InitDefaultsSetUserBasicInfoReplyImpl();
void InitDefaultsSetUserBasicInfoReply();
void InitDefaultsLoginRequestImpl();
void InitDefaultsLoginRequest();
void InitDefaultsLoginReplyImpl();
void InitDefaultsLoginReply();
void InitDefaultsLogoutRequestImpl();
void InitDefaultsLogoutRequest();
void InitDefaultsPingRequestImpl();
void InitDefaultsPingRequest();
void InitDefaultsPingReplyImpl();
void InitDefaultsPingReply();
inline void InitDefaults() {
  InitDefaultsGetPiCodeRequest();
  InitDefaultsGetPiCodeReply();
  InitDefaultsGetSmsVericodeRequest();
  InitDefaultsGetSmsVericodeReply();
  InitDefaultsSignupRequest();
  InitDefaultsSignupReply();
  InitDefaultsSetUserBasicInfoRequest();
  InitDefaultsSetUserBasicInfoReply();
  InitDefaultsLoginRequest();
  InitDefaultsLoginReply();
  InitDefaultsLogoutRequest();
  InitDefaultsPingRequest();
  InitDefaultsPingReply();
}
}  // namespace protobuf_sea_2eproto
namespace sea_proto {
class GetPiCodeReply;
class GetPiCodeReplyDefaultTypeInternal;
extern GetPiCodeReplyDefaultTypeInternal _GetPiCodeReply_default_instance_;
class GetPiCodeRequest;
class GetPiCodeRequestDefaultTypeInternal;
extern GetPiCodeRequestDefaultTypeInternal _GetPiCodeRequest_default_instance_;
class GetSmsVericodeReply;
class GetSmsVericodeReplyDefaultTypeInternal;
extern GetSmsVericodeReplyDefaultTypeInternal _GetSmsVericodeReply_default_instance_;
class GetSmsVericodeRequest;
class GetSmsVericodeRequestDefaultTypeInternal;
extern GetSmsVericodeRequestDefaultTypeInternal _GetSmsVericodeRequest_default_instance_;
class LoginReply;
class LoginReplyDefaultTypeInternal;
extern LoginReplyDefaultTypeInternal _LoginReply_default_instance_;
class LoginRequest;
class LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LogoutRequest;
class LogoutRequestDefaultTypeInternal;
extern LogoutRequestDefaultTypeInternal _LogoutRequest_default_instance_;
class PingReply;
class PingReplyDefaultTypeInternal;
extern PingReplyDefaultTypeInternal _PingReply_default_instance_;
class PingRequest;
class PingRequestDefaultTypeInternal;
extern PingRequestDefaultTypeInternal _PingRequest_default_instance_;
class SetUserBasicInfoReply;
class SetUserBasicInfoReplyDefaultTypeInternal;
extern SetUserBasicInfoReplyDefaultTypeInternal _SetUserBasicInfoReply_default_instance_;
class SetUserBasicInfoRequest;
class SetUserBasicInfoRequestDefaultTypeInternal;
extern SetUserBasicInfoRequestDefaultTypeInternal _SetUserBasicInfoRequest_default_instance_;
class SignupReply;
class SignupReplyDefaultTypeInternal;
extern SignupReplyDefaultTypeInternal _SignupReply_default_instance_;
class SignupRequest;
class SignupRequestDefaultTypeInternal;
extern SignupRequestDefaultTypeInternal _SignupRequest_default_instance_;
}  // namespace sea_proto
namespace google {
namespace protobuf {
template<> ::sea_proto::GetPiCodeReply* Arena::Create< ::sea_proto::GetPiCodeReply>(Arena*);
template<> ::sea_proto::GetPiCodeRequest* Arena::Create< ::sea_proto::GetPiCodeRequest>(Arena*);
template<> ::sea_proto::GetSmsVericodeReply* Arena::Create< ::sea_proto::GetSmsVericodeReply>(Arena*);
template<> ::sea_proto::GetSmsVericodeRequest* Arena::Create< ::sea_proto::GetSmsVericodeRequest>(Arena*);
template<> ::sea_proto::LoginReply* Arena::Create< ::sea_proto::LoginReply>(Arena*);
template<> ::sea_proto::LoginRequest* Arena::Create< ::sea_proto::LoginRequest>(Arena*);
template<> ::sea_proto::LogoutRequest* Arena::Create< ::sea_proto::LogoutRequest>(Arena*);
template<> ::sea_proto::PingReply* Arena::Create< ::sea_proto::PingReply>(Arena*);
template<> ::sea_proto::PingRequest* Arena::Create< ::sea_proto::PingRequest>(Arena*);
template<> ::sea_proto::SetUserBasicInfoReply* Arena::Create< ::sea_proto::SetUserBasicInfoReply>(Arena*);
template<> ::sea_proto::SetUserBasicInfoRequest* Arena::Create< ::sea_proto::SetUserBasicInfoRequest>(Arena*);
template<> ::sea_proto::SignupReply* Arena::Create< ::sea_proto::SignupReply>(Arena*);
template<> ::sea_proto::SignupRequest* Arena::Create< ::sea_proto::SignupRequest>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace sea_proto {

// ===================================================================

class GetPiCodeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sea_proto.GetPiCodeRequest) */ {
 public:
  GetPiCodeRequest();
  virtual ~GetPiCodeRequest();

  GetPiCodeRequest(const GetPiCodeRequest& from);

  inline GetPiCodeRequest& operator=(const GetPiCodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetPiCodeRequest(GetPiCodeRequest&& from) noexcept
    : GetPiCodeRequest() {
    *this = ::std::move(from);
  }

  inline GetPiCodeRequest& operator=(GetPiCodeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPiCodeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetPiCodeRequest* internal_default_instance() {
    return reinterpret_cast<const GetPiCodeRequest*>(
               &_GetPiCodeRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(GetPiCodeRequest* other);
  friend void swap(GetPiCodeRequest& a, GetPiCodeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetPiCodeRequest* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<GetPiCodeRequest>(NULL);
  }

  GetPiCodeRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<GetPiCodeRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetPiCodeRequest& from);
  void MergeFrom(const GetPiCodeRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetPiCodeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sea_proto.ClientInfo client_info = 9;
  bool has_client_info() const;
  void clear_client_info();
  static const int kClientInfoFieldNumber = 9;
  const ::sea_proto::ClientInfo& client_info() const;
  ::sea_proto::ClientInfo* release_client_info();
  ::sea_proto::ClientInfo* mutable_client_info();
  void set_allocated_client_info(::sea_proto::ClientInfo* client_info);

  // @@protoc_insertion_point(class_scope:sea_proto.GetPiCodeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::sea_proto::ClientInfo* client_info_;
  mutable int _cached_size_;
  friend struct ::protobuf_sea_2eproto::TableStruct;
  friend void ::protobuf_sea_2eproto::InitDefaultsGetPiCodeRequestImpl();
};
// -------------------------------------------------------------------

class GetPiCodeReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sea_proto.GetPiCodeReply) */ {
 public:
  GetPiCodeReply();
  virtual ~GetPiCodeReply();

  GetPiCodeReply(const GetPiCodeReply& from);

  inline GetPiCodeReply& operator=(const GetPiCodeReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetPiCodeReply(GetPiCodeReply&& from) noexcept
    : GetPiCodeReply() {
    *this = ::std::move(from);
  }

  inline GetPiCodeReply& operator=(GetPiCodeReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPiCodeReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetPiCodeReply* internal_default_instance() {
    return reinterpret_cast<const GetPiCodeReply*>(
               &_GetPiCodeReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(GetPiCodeReply* other);
  friend void swap(GetPiCodeReply& a, GetPiCodeReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetPiCodeReply* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<GetPiCodeReply>(NULL);
  }

  GetPiCodeReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<GetPiCodeReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetPiCodeReply& from);
  void MergeFrom(const GetPiCodeReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetPiCodeReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string session_id = 2;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  const ::std::string& session_id() const;
  void set_session_id(const ::std::string& value);
  #if LANG_CXX11
  void set_session_id(::std::string&& value);
  #endif
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  ::std::string* mutable_session_id();
  ::std::string* release_session_id();
  void set_allocated_session_id(::std::string* session_id);

  // bytes img_data = 3;
  void clear_img_data();
  static const int kImgDataFieldNumber = 3;
  const ::std::string& img_data() const;
  void set_img_data(const ::std::string& value);
  #if LANG_CXX11
  void set_img_data(::std::string&& value);
  #endif
  void set_img_data(const char* value);
  void set_img_data(const void* value, size_t size);
  ::std::string* mutable_img_data();
  ::std::string* release_img_data();
  void set_allocated_img_data(::std::string* img_data);

  // .sea_proto.ErrorInfo err_info = 1;
  bool has_err_info() const;
  void clear_err_info();
  static const int kErrInfoFieldNumber = 1;
  const ::sea_proto::ErrorInfo& err_info() const;
  ::sea_proto::ErrorInfo* release_err_info();
  ::sea_proto::ErrorInfo* mutable_err_info();
  void set_allocated_err_info(::sea_proto::ErrorInfo* err_info);

  // @@protoc_insertion_point(class_scope:sea_proto.GetPiCodeReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr session_id_;
  ::google::protobuf::internal::ArenaStringPtr img_data_;
  ::sea_proto::ErrorInfo* err_info_;
  mutable int _cached_size_;
  friend struct ::protobuf_sea_2eproto::TableStruct;
  friend void ::protobuf_sea_2eproto::InitDefaultsGetPiCodeReplyImpl();
};
// -------------------------------------------------------------------

class GetSmsVericodeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sea_proto.GetSmsVericodeRequest) */ {
 public:
  GetSmsVericodeRequest();
  virtual ~GetSmsVericodeRequest();

  GetSmsVericodeRequest(const GetSmsVericodeRequest& from);

  inline GetSmsVericodeRequest& operator=(const GetSmsVericodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetSmsVericodeRequest(GetSmsVericodeRequest&& from) noexcept
    : GetSmsVericodeRequest() {
    *this = ::std::move(from);
  }

  inline GetSmsVericodeRequest& operator=(GetSmsVericodeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSmsVericodeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetSmsVericodeRequest* internal_default_instance() {
    return reinterpret_cast<const GetSmsVericodeRequest*>(
               &_GetSmsVericodeRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(GetSmsVericodeRequest* other);
  friend void swap(GetSmsVericodeRequest& a, GetSmsVericodeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetSmsVericodeRequest* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<GetSmsVericodeRequest>(NULL);
  }

  GetSmsVericodeRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<GetSmsVericodeRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetSmsVericodeRequest& from);
  void MergeFrom(const GetSmsVericodeRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetSmsVericodeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string session_id = 1;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  const ::std::string& session_id() const;
  void set_session_id(const ::std::string& value);
  #if LANG_CXX11
  void set_session_id(::std::string&& value);
  #endif
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  ::std::string* mutable_session_id();
  ::std::string* release_session_id();
  void set_allocated_session_id(::std::string* session_id);

  // string pic_code = 2;
  void clear_pic_code();
  static const int kPicCodeFieldNumber = 2;
  const ::std::string& pic_code() const;
  void set_pic_code(const ::std::string& value);
  #if LANG_CXX11
  void set_pic_code(::std::string&& value);
  #endif
  void set_pic_code(const char* value);
  void set_pic_code(const char* value, size_t size);
  ::std::string* mutable_pic_code();
  ::std::string* release_pic_code();
  void set_allocated_pic_code(::std::string* pic_code);

  // string phone = 3;
  void clear_phone();
  static const int kPhoneFieldNumber = 3;
  const ::std::string& phone() const;
  void set_phone(const ::std::string& value);
  #if LANG_CXX11
  void set_phone(::std::string&& value);
  #endif
  void set_phone(const char* value);
  void set_phone(const char* value, size_t size);
  ::std::string* mutable_phone();
  ::std::string* release_phone();
  void set_allocated_phone(::std::string* phone);

  // .sea_proto.ClientInfo client_info = 9;
  bool has_client_info() const;
  void clear_client_info();
  static const int kClientInfoFieldNumber = 9;
  const ::sea_proto::ClientInfo& client_info() const;
  ::sea_proto::ClientInfo* release_client_info();
  ::sea_proto::ClientInfo* mutable_client_info();
  void set_allocated_client_info(::sea_proto::ClientInfo* client_info);

  // @@protoc_insertion_point(class_scope:sea_proto.GetSmsVericodeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr session_id_;
  ::google::protobuf::internal::ArenaStringPtr pic_code_;
  ::google::protobuf::internal::ArenaStringPtr phone_;
  ::sea_proto::ClientInfo* client_info_;
  mutable int _cached_size_;
  friend struct ::protobuf_sea_2eproto::TableStruct;
  friend void ::protobuf_sea_2eproto::InitDefaultsGetSmsVericodeRequestImpl();
};
// -------------------------------------------------------------------

class GetSmsVericodeReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sea_proto.GetSmsVericodeReply) */ {
 public:
  GetSmsVericodeReply();
  virtual ~GetSmsVericodeReply();

  GetSmsVericodeReply(const GetSmsVericodeReply& from);

  inline GetSmsVericodeReply& operator=(const GetSmsVericodeReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetSmsVericodeReply(GetSmsVericodeReply&& from) noexcept
    : GetSmsVericodeReply() {
    *this = ::std::move(from);
  }

  inline GetSmsVericodeReply& operator=(GetSmsVericodeReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSmsVericodeReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetSmsVericodeReply* internal_default_instance() {
    return reinterpret_cast<const GetSmsVericodeReply*>(
               &_GetSmsVericodeReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(GetSmsVericodeReply* other);
  friend void swap(GetSmsVericodeReply& a, GetSmsVericodeReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetSmsVericodeReply* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<GetSmsVericodeReply>(NULL);
  }

  GetSmsVericodeReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<GetSmsVericodeReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetSmsVericodeReply& from);
  void MergeFrom(const GetSmsVericodeReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetSmsVericodeReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sea_proto.ErrorInfo err_info = 1;
  bool has_err_info() const;
  void clear_err_info();
  static const int kErrInfoFieldNumber = 1;
  const ::sea_proto::ErrorInfo& err_info() const;
  ::sea_proto::ErrorInfo* release_err_info();
  ::sea_proto::ErrorInfo* mutable_err_info();
  void set_allocated_err_info(::sea_proto::ErrorInfo* err_info);

  // int32 expire_time = 2;
  void clear_expire_time();
  static const int kExpireTimeFieldNumber = 2;
  ::google::protobuf::int32 expire_time() const;
  void set_expire_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sea_proto.GetSmsVericodeReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::sea_proto::ErrorInfo* err_info_;
  ::google::protobuf::int32 expire_time_;
  mutable int _cached_size_;
  friend struct ::protobuf_sea_2eproto::TableStruct;
  friend void ::protobuf_sea_2eproto::InitDefaultsGetSmsVericodeReplyImpl();
};
// -------------------------------------------------------------------

class SignupRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sea_proto.SignupRequest) */ {
 public:
  SignupRequest();
  virtual ~SignupRequest();

  SignupRequest(const SignupRequest& from);

  inline SignupRequest& operator=(const SignupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SignupRequest(SignupRequest&& from) noexcept
    : SignupRequest() {
    *this = ::std::move(from);
  }

  inline SignupRequest& operator=(SignupRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SignupRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignupRequest* internal_default_instance() {
    return reinterpret_cast<const SignupRequest*>(
               &_SignupRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(SignupRequest* other);
  friend void swap(SignupRequest& a, SignupRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignupRequest* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<SignupRequest>(NULL);
  }

  SignupRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<SignupRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SignupRequest& from);
  void MergeFrom(const SignupRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SignupRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string phone = 1;
  void clear_phone();
  static const int kPhoneFieldNumber = 1;
  const ::std::string& phone() const;
  void set_phone(const ::std::string& value);
  #if LANG_CXX11
  void set_phone(::std::string&& value);
  #endif
  void set_phone(const char* value);
  void set_phone(const char* value, size_t size);
  ::std::string* mutable_phone();
  ::std::string* release_phone();
  void set_allocated_phone(::std::string* phone);

  // string session_id = 2;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  const ::std::string& session_id() const;
  void set_session_id(const ::std::string& value);
  #if LANG_CXX11
  void set_session_id(::std::string&& value);
  #endif
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  ::std::string* mutable_session_id();
  ::std::string* release_session_id();
  void set_allocated_session_id(::std::string* session_id);

  // string verify_code = 3;
  void clear_verify_code();
  static const int kVerifyCodeFieldNumber = 3;
  const ::std::string& verify_code() const;
  void set_verify_code(const ::std::string& value);
  #if LANG_CXX11
  void set_verify_code(::std::string&& value);
  #endif
  void set_verify_code(const char* value);
  void set_verify_code(const char* value, size_t size);
  ::std::string* mutable_verify_code();
  ::std::string* release_verify_code();
  void set_allocated_verify_code(::std::string* verify_code);

  // string passwd = 4;
  void clear_passwd();
  static const int kPasswdFieldNumber = 4;
  const ::std::string& passwd() const;
  void set_passwd(const ::std::string& value);
  #if LANG_CXX11
  void set_passwd(::std::string&& value);
  #endif
  void set_passwd(const char* value);
  void set_passwd(const char* value, size_t size);
  ::std::string* mutable_passwd();
  ::std::string* release_passwd();
  void set_allocated_passwd(::std::string* passwd);

  // string name = 5;
  void clear_name();
  static const int kNameFieldNumber = 5;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .sea_proto.ClientInfo client_info = 9;
  bool has_client_info() const;
  void clear_client_info();
  static const int kClientInfoFieldNumber = 9;
  const ::sea_proto::ClientInfo& client_info() const;
  ::sea_proto::ClientInfo* release_client_info();
  ::sea_proto::ClientInfo* mutable_client_info();
  void set_allocated_client_info(::sea_proto::ClientInfo* client_info);

  // @@protoc_insertion_point(class_scope:sea_proto.SignupRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr phone_;
  ::google::protobuf::internal::ArenaStringPtr session_id_;
  ::google::protobuf::internal::ArenaStringPtr verify_code_;
  ::google::protobuf::internal::ArenaStringPtr passwd_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::sea_proto::ClientInfo* client_info_;
  mutable int _cached_size_;
  friend struct ::protobuf_sea_2eproto::TableStruct;
  friend void ::protobuf_sea_2eproto::InitDefaultsSignupRequestImpl();
};
// -------------------------------------------------------------------

class SignupReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sea_proto.SignupReply) */ {
 public:
  SignupReply();
  virtual ~SignupReply();

  SignupReply(const SignupReply& from);

  inline SignupReply& operator=(const SignupReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SignupReply(SignupReply&& from) noexcept
    : SignupReply() {
    *this = ::std::move(from);
  }

  inline SignupReply& operator=(SignupReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SignupReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignupReply* internal_default_instance() {
    return reinterpret_cast<const SignupReply*>(
               &_SignupReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(SignupReply* other);
  friend void swap(SignupReply& a, SignupReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignupReply* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<SignupReply>(NULL);
  }

  SignupReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<SignupReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SignupReply& from);
  void MergeFrom(const SignupReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SignupReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sea_proto.ErrorInfo err_info = 1;
  bool has_err_info() const;
  void clear_err_info();
  static const int kErrInfoFieldNumber = 1;
  const ::sea_proto::ErrorInfo& err_info() const;
  ::sea_proto::ErrorInfo* release_err_info();
  ::sea_proto::ErrorInfo* mutable_err_info();
  void set_allocated_err_info(::sea_proto::ErrorInfo* err_info);

  // int64 uid = 2;
  void clear_uid();
  static const int kUidFieldNumber = 2;
  ::google::protobuf::int64 uid() const;
  void set_uid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:sea_proto.SignupReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::sea_proto::ErrorInfo* err_info_;
  ::google::protobuf::int64 uid_;
  mutable int _cached_size_;
  friend struct ::protobuf_sea_2eproto::TableStruct;
  friend void ::protobuf_sea_2eproto::InitDefaultsSignupReplyImpl();
};
// -------------------------------------------------------------------

class SetUserBasicInfoRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sea_proto.SetUserBasicInfoRequest) */ {
 public:
  SetUserBasicInfoRequest();
  virtual ~SetUserBasicInfoRequest();

  SetUserBasicInfoRequest(const SetUserBasicInfoRequest& from);

  inline SetUserBasicInfoRequest& operator=(const SetUserBasicInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetUserBasicInfoRequest(SetUserBasicInfoRequest&& from) noexcept
    : SetUserBasicInfoRequest() {
    *this = ::std::move(from);
  }

  inline SetUserBasicInfoRequest& operator=(SetUserBasicInfoRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetUserBasicInfoRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetUserBasicInfoRequest* internal_default_instance() {
    return reinterpret_cast<const SetUserBasicInfoRequest*>(
               &_SetUserBasicInfoRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(SetUserBasicInfoRequest* other);
  friend void swap(SetUserBasicInfoRequest& a, SetUserBasicInfoRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetUserBasicInfoRequest* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<SetUserBasicInfoRequest>(NULL);
  }

  SetUserBasicInfoRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<SetUserBasicInfoRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SetUserBasicInfoRequest& from);
  void MergeFrom(const SetUserBasicInfoRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SetUserBasicInfoRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .user_proto.UserBasicInfo user_info = 1;
  bool has_user_info() const;
  void clear_user_info();
  static const int kUserInfoFieldNumber = 1;
  const ::user_proto::UserBasicInfo& user_info() const;
  ::user_proto::UserBasicInfo* release_user_info();
  ::user_proto::UserBasicInfo* mutable_user_info();
  void set_allocated_user_info(::user_proto::UserBasicInfo* user_info);

  // .sea_proto.ClientInfo client_info = 9;
  bool has_client_info() const;
  void clear_client_info();
  static const int kClientInfoFieldNumber = 9;
  const ::sea_proto::ClientInfo& client_info() const;
  ::sea_proto::ClientInfo* release_client_info();
  ::sea_proto::ClientInfo* mutable_client_info();
  void set_allocated_client_info(::sea_proto::ClientInfo* client_info);

  // @@protoc_insertion_point(class_scope:sea_proto.SetUserBasicInfoRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::user_proto::UserBasicInfo* user_info_;
  ::sea_proto::ClientInfo* client_info_;
  mutable int _cached_size_;
  friend struct ::protobuf_sea_2eproto::TableStruct;
  friend void ::protobuf_sea_2eproto::InitDefaultsSetUserBasicInfoRequestImpl();
};
// -------------------------------------------------------------------

class SetUserBasicInfoReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sea_proto.SetUserBasicInfoReply) */ {
 public:
  SetUserBasicInfoReply();
  virtual ~SetUserBasicInfoReply();

  SetUserBasicInfoReply(const SetUserBasicInfoReply& from);

  inline SetUserBasicInfoReply& operator=(const SetUserBasicInfoReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetUserBasicInfoReply(SetUserBasicInfoReply&& from) noexcept
    : SetUserBasicInfoReply() {
    *this = ::std::move(from);
  }

  inline SetUserBasicInfoReply& operator=(SetUserBasicInfoReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetUserBasicInfoReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetUserBasicInfoReply* internal_default_instance() {
    return reinterpret_cast<const SetUserBasicInfoReply*>(
               &_SetUserBasicInfoReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(SetUserBasicInfoReply* other);
  friend void swap(SetUserBasicInfoReply& a, SetUserBasicInfoReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetUserBasicInfoReply* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<SetUserBasicInfoReply>(NULL);
  }

  SetUserBasicInfoReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<SetUserBasicInfoReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SetUserBasicInfoReply& from);
  void MergeFrom(const SetUserBasicInfoReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SetUserBasicInfoReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sea_proto.ErrorInfo err_info = 1;
  bool has_err_info() const;
  void clear_err_info();
  static const int kErrInfoFieldNumber = 1;
  const ::sea_proto::ErrorInfo& err_info() const;
  ::sea_proto::ErrorInfo* release_err_info();
  ::sea_proto::ErrorInfo* mutable_err_info();
  void set_allocated_err_info(::sea_proto::ErrorInfo* err_info);

  // .user_proto.UserBasicInfo user_info = 2;
  bool has_user_info() const;
  void clear_user_info();
  static const int kUserInfoFieldNumber = 2;
  const ::user_proto::UserBasicInfo& user_info() const;
  ::user_proto::UserBasicInfo* release_user_info();
  ::user_proto::UserBasicInfo* mutable_user_info();
  void set_allocated_user_info(::user_proto::UserBasicInfo* user_info);

  // @@protoc_insertion_point(class_scope:sea_proto.SetUserBasicInfoReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::sea_proto::ErrorInfo* err_info_;
  ::user_proto::UserBasicInfo* user_info_;
  mutable int _cached_size_;
  friend struct ::protobuf_sea_2eproto::TableStruct;
  friend void ::protobuf_sea_2eproto::InitDefaultsSetUserBasicInfoReplyImpl();
};
// -------------------------------------------------------------------

class LoginRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sea_proto.LoginRequest) */ {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(LoginRequest* other);
  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginRequest* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<LoginRequest>(NULL);
  }

  LoginRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<LoginRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoginRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string phone = 1;
  void clear_phone();
  static const int kPhoneFieldNumber = 1;
  const ::std::string& phone() const;
  void set_phone(const ::std::string& value);
  #if LANG_CXX11
  void set_phone(::std::string&& value);
  #endif
  void set_phone(const char* value);
  void set_phone(const char* value, size_t size);
  ::std::string* mutable_phone();
  ::std::string* release_phone();
  void set_allocated_phone(::std::string* phone);

  // string passwd = 2;
  void clear_passwd();
  static const int kPasswdFieldNumber = 2;
  const ::std::string& passwd() const;
  void set_passwd(const ::std::string& value);
  #if LANG_CXX11
  void set_passwd(::std::string&& value);
  #endif
  void set_passwd(const char* value);
  void set_passwd(const char* value, size_t size);
  ::std::string* mutable_passwd();
  ::std::string* release_passwd();
  void set_allocated_passwd(::std::string* passwd);

  // string openid = 3;
  void clear_openid();
  static const int kOpenidFieldNumber = 3;
  const ::std::string& openid() const;
  void set_openid(const ::std::string& value);
  #if LANG_CXX11
  void set_openid(::std::string&& value);
  #endif
  void set_openid(const char* value);
  void set_openid(const char* value, size_t size);
  ::std::string* mutable_openid();
  ::std::string* release_openid();
  void set_allocated_openid(::std::string* openid);

  // string openid_sig = 4;
  void clear_openid_sig();
  static const int kOpenidSigFieldNumber = 4;
  const ::std::string& openid_sig() const;
  void set_openid_sig(const ::std::string& value);
  #if LANG_CXX11
  void set_openid_sig(::std::string&& value);
  #endif
  void set_openid_sig(const char* value);
  void set_openid_sig(const char* value, size_t size);
  ::std::string* mutable_openid_sig();
  ::std::string* release_openid_sig();
  void set_allocated_openid_sig(::std::string* openid_sig);

  // .sea_proto.ClientInfo client_info = 9;
  bool has_client_info() const;
  void clear_client_info();
  static const int kClientInfoFieldNumber = 9;
  const ::sea_proto::ClientInfo& client_info() const;
  ::sea_proto::ClientInfo* release_client_info();
  ::sea_proto::ClientInfo* mutable_client_info();
  void set_allocated_client_info(::sea_proto::ClientInfo* client_info);

  // @@protoc_insertion_point(class_scope:sea_proto.LoginRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr phone_;
  ::google::protobuf::internal::ArenaStringPtr passwd_;
  ::google::protobuf::internal::ArenaStringPtr openid_;
  ::google::protobuf::internal::ArenaStringPtr openid_sig_;
  ::sea_proto::ClientInfo* client_info_;
  mutable int _cached_size_;
  friend struct ::protobuf_sea_2eproto::TableStruct;
  friend void ::protobuf_sea_2eproto::InitDefaultsLoginRequestImpl();
};
// -------------------------------------------------------------------

class LoginReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sea_proto.LoginReply) */ {
 public:
  LoginReply();
  virtual ~LoginReply();

  LoginReply(const LoginReply& from);

  inline LoginReply& operator=(const LoginReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginReply(LoginReply&& from) noexcept
    : LoginReply() {
    *this = ::std::move(from);
  }

  inline LoginReply& operator=(LoginReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginReply* internal_default_instance() {
    return reinterpret_cast<const LoginReply*>(
               &_LoginReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(LoginReply* other);
  friend void swap(LoginReply& a, LoginReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginReply* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<LoginReply>(NULL);
  }

  LoginReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<LoginReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoginReply& from);
  void MergeFrom(const LoginReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoginReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string session = 2;
  void clear_session();
  static const int kSessionFieldNumber = 2;
  const ::std::string& session() const;
  void set_session(const ::std::string& value);
  #if LANG_CXX11
  void set_session(::std::string&& value);
  #endif
  void set_session(const char* value);
  void set_session(const char* value, size_t size);
  ::std::string* mutable_session();
  ::std::string* release_session();
  void set_allocated_session(::std::string* session);

  // .sea_proto.ErrorInfo err_info = 1;
  bool has_err_info() const;
  void clear_err_info();
  static const int kErrInfoFieldNumber = 1;
  const ::sea_proto::ErrorInfo& err_info() const;
  ::sea_proto::ErrorInfo* release_err_info();
  ::sea_proto::ErrorInfo* mutable_err_info();
  void set_allocated_err_info(::sea_proto::ErrorInfo* err_info);

  // .user_proto.UserBasicInfo user_info = 9;
  bool has_user_info() const;
  void clear_user_info();
  static const int kUserInfoFieldNumber = 9;
  const ::user_proto::UserBasicInfo& user_info() const;
  ::user_proto::UserBasicInfo* release_user_info();
  ::user_proto::UserBasicInfo* mutable_user_info();
  void set_allocated_user_info(::user_proto::UserBasicInfo* user_info);

  // @@protoc_insertion_point(class_scope:sea_proto.LoginReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr session_;
  ::sea_proto::ErrorInfo* err_info_;
  ::user_proto::UserBasicInfo* user_info_;
  mutable int _cached_size_;
  friend struct ::protobuf_sea_2eproto::TableStruct;
  friend void ::protobuf_sea_2eproto::InitDefaultsLoginReplyImpl();
};
// -------------------------------------------------------------------

class LogoutRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sea_proto.LogoutRequest) */ {
 public:
  LogoutRequest();
  virtual ~LogoutRequest();

  LogoutRequest(const LogoutRequest& from);

  inline LogoutRequest& operator=(const LogoutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogoutRequest(LogoutRequest&& from) noexcept
    : LogoutRequest() {
    *this = ::std::move(from);
  }

  inline LogoutRequest& operator=(LogoutRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogoutRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogoutRequest* internal_default_instance() {
    return reinterpret_cast<const LogoutRequest*>(
               &_LogoutRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(LogoutRequest* other);
  friend void swap(LogoutRequest& a, LogoutRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogoutRequest* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<LogoutRequest>(NULL);
  }

  LogoutRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<LogoutRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LogoutRequest& from);
  void MergeFrom(const LogoutRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LogoutRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sea_proto.ClientInfo client_info = 1;
  bool has_client_info() const;
  void clear_client_info();
  static const int kClientInfoFieldNumber = 1;
  const ::sea_proto::ClientInfo& client_info() const;
  ::sea_proto::ClientInfo* release_client_info();
  ::sea_proto::ClientInfo* mutable_client_info();
  void set_allocated_client_info(::sea_proto::ClientInfo* client_info);

  // @@protoc_insertion_point(class_scope:sea_proto.LogoutRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::sea_proto::ClientInfo* client_info_;
  mutable int _cached_size_;
  friend struct ::protobuf_sea_2eproto::TableStruct;
  friend void ::protobuf_sea_2eproto::InitDefaultsLogoutRequestImpl();
};
// -------------------------------------------------------------------

class PingRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sea_proto.PingRequest) */ {
 public:
  PingRequest();
  virtual ~PingRequest();

  PingRequest(const PingRequest& from);

  inline PingRequest& operator=(const PingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PingRequest(PingRequest&& from) noexcept
    : PingRequest() {
    *this = ::std::move(from);
  }

  inline PingRequest& operator=(PingRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PingRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PingRequest* internal_default_instance() {
    return reinterpret_cast<const PingRequest*>(
               &_PingRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(PingRequest* other);
  friend void swap(PingRequest& a, PingRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PingRequest* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<PingRequest>(NULL);
  }

  PingRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<PingRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PingRequest& from);
  void MergeFrom(const PingRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PingRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sea_proto.ClientInfo client_info = 1;
  bool has_client_info() const;
  void clear_client_info();
  static const int kClientInfoFieldNumber = 1;
  const ::sea_proto::ClientInfo& client_info() const;
  ::sea_proto::ClientInfo* release_client_info();
  ::sea_proto::ClientInfo* mutable_client_info();
  void set_allocated_client_info(::sea_proto::ClientInfo* client_info);

  // @@protoc_insertion_point(class_scope:sea_proto.PingRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::sea_proto::ClientInfo* client_info_;
  mutable int _cached_size_;
  friend struct ::protobuf_sea_2eproto::TableStruct;
  friend void ::protobuf_sea_2eproto::InitDefaultsPingRequestImpl();
};
// -------------------------------------------------------------------

class PingReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sea_proto.PingReply) */ {
 public:
  PingReply();
  virtual ~PingReply();

  PingReply(const PingReply& from);

  inline PingReply& operator=(const PingReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PingReply(PingReply&& from) noexcept
    : PingReply() {
    *this = ::std::move(from);
  }

  inline PingReply& operator=(PingReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PingReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PingReply* internal_default_instance() {
    return reinterpret_cast<const PingReply*>(
               &_PingReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(PingReply* other);
  friend void swap(PingReply& a, PingReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PingReply* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<PingReply>(NULL);
  }

  PingReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<PingReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PingReply& from);
  void MergeFrom(const PingReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PingReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sea_proto.ErrorInfo err_info = 1;
  bool has_err_info() const;
  void clear_err_info();
  static const int kErrInfoFieldNumber = 1;
  const ::sea_proto::ErrorInfo& err_info() const;
  ::sea_proto::ErrorInfo* release_err_info();
  ::sea_proto::ErrorInfo* mutable_err_info();
  void set_allocated_err_info(::sea_proto::ErrorInfo* err_info);

  // @@protoc_insertion_point(class_scope:sea_proto.PingReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::sea_proto::ErrorInfo* err_info_;
  mutable int _cached_size_;
  friend struct ::protobuf_sea_2eproto::TableStruct;
  friend void ::protobuf_sea_2eproto::InitDefaultsPingReplyImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetPiCodeRequest

// .sea_proto.ClientInfo client_info = 9;
inline bool GetPiCodeRequest::has_client_info() const {
  return this != internal_default_instance() && client_info_ != NULL;
}
inline const ::sea_proto::ClientInfo& GetPiCodeRequest::client_info() const {
  const ::sea_proto::ClientInfo* p = client_info_;
  // @@protoc_insertion_point(field_get:sea_proto.GetPiCodeRequest.client_info)
  return p != NULL ? *p : *reinterpret_cast<const ::sea_proto::ClientInfo*>(
      &::sea_proto::_ClientInfo_default_instance_);
}
inline ::sea_proto::ClientInfo* GetPiCodeRequest::release_client_info() {
  // @@protoc_insertion_point(field_release:sea_proto.GetPiCodeRequest.client_info)
  
  ::sea_proto::ClientInfo* temp = client_info_;
  client_info_ = NULL;
  return temp;
}
inline ::sea_proto::ClientInfo* GetPiCodeRequest::mutable_client_info() {
  
  if (client_info_ == NULL) {
    client_info_ = ::google::protobuf::Arena::Create< ::sea_proto::ClientInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sea_proto.GetPiCodeRequest.client_info)
  return client_info_;
}
inline void GetPiCodeRequest::set_allocated_client_info(::sea_proto::ClientInfo* client_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(client_info_);
  }
  if (client_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      client_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, client_info, submessage_arena);
    }
    
  } else {
    
  }
  client_info_ = client_info;
  // @@protoc_insertion_point(field_set_allocated:sea_proto.GetPiCodeRequest.client_info)
}

// -------------------------------------------------------------------

// GetPiCodeReply

// .sea_proto.ErrorInfo err_info = 1;
inline bool GetPiCodeReply::has_err_info() const {
  return this != internal_default_instance() && err_info_ != NULL;
}
inline const ::sea_proto::ErrorInfo& GetPiCodeReply::err_info() const {
  const ::sea_proto::ErrorInfo* p = err_info_;
  // @@protoc_insertion_point(field_get:sea_proto.GetPiCodeReply.err_info)
  return p != NULL ? *p : *reinterpret_cast<const ::sea_proto::ErrorInfo*>(
      &::sea_proto::_ErrorInfo_default_instance_);
}
inline ::sea_proto::ErrorInfo* GetPiCodeReply::release_err_info() {
  // @@protoc_insertion_point(field_release:sea_proto.GetPiCodeReply.err_info)
  
  ::sea_proto::ErrorInfo* temp = err_info_;
  err_info_ = NULL;
  return temp;
}
inline ::sea_proto::ErrorInfo* GetPiCodeReply::mutable_err_info() {
  
  if (err_info_ == NULL) {
    err_info_ = ::google::protobuf::Arena::Create< ::sea_proto::ErrorInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sea_proto.GetPiCodeReply.err_info)
  return err_info_;
}
inline void GetPiCodeReply::set_allocated_err_info(::sea_proto::ErrorInfo* err_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(err_info_);
  }
  if (err_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      err_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, err_info, submessage_arena);
    }
    
  } else {
    
  }
  err_info_ = err_info;
  // @@protoc_insertion_point(field_set_allocated:sea_proto.GetPiCodeReply.err_info)
}

// string session_id = 2;
inline void GetPiCodeReply::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetPiCodeReply::session_id() const {
  // @@protoc_insertion_point(field_get:sea_proto.GetPiCodeReply.session_id)
  return session_id_.GetNoArena();
}
inline void GetPiCodeReply::set_session_id(const ::std::string& value) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sea_proto.GetPiCodeReply.session_id)
}
#if LANG_CXX11
inline void GetPiCodeReply::set_session_id(::std::string&& value) {
  
  session_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sea_proto.GetPiCodeReply.session_id)
}
#endif
inline void GetPiCodeReply::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sea_proto.GetPiCodeReply.session_id)
}
inline void GetPiCodeReply::set_session_id(const char* value, size_t size) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sea_proto.GetPiCodeReply.session_id)
}
inline ::std::string* GetPiCodeReply::mutable_session_id() {
  
  // @@protoc_insertion_point(field_mutable:sea_proto.GetPiCodeReply.session_id)
  return session_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetPiCodeReply::release_session_id() {
  // @@protoc_insertion_point(field_release:sea_proto.GetPiCodeReply.session_id)
  
  return session_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetPiCodeReply::set_allocated_session_id(::std::string* session_id) {
  if (session_id != NULL) {
    
  } else {
    
  }
  session_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:sea_proto.GetPiCodeReply.session_id)
}

// bytes img_data = 3;
inline void GetPiCodeReply::clear_img_data() {
  img_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetPiCodeReply::img_data() const {
  // @@protoc_insertion_point(field_get:sea_proto.GetPiCodeReply.img_data)
  return img_data_.GetNoArena();
}
inline void GetPiCodeReply::set_img_data(const ::std::string& value) {
  
  img_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sea_proto.GetPiCodeReply.img_data)
}
#if LANG_CXX11
inline void GetPiCodeReply::set_img_data(::std::string&& value) {
  
  img_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sea_proto.GetPiCodeReply.img_data)
}
#endif
inline void GetPiCodeReply::set_img_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  img_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sea_proto.GetPiCodeReply.img_data)
}
inline void GetPiCodeReply::set_img_data(const void* value, size_t size) {
  
  img_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sea_proto.GetPiCodeReply.img_data)
}
inline ::std::string* GetPiCodeReply::mutable_img_data() {
  
  // @@protoc_insertion_point(field_mutable:sea_proto.GetPiCodeReply.img_data)
  return img_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetPiCodeReply::release_img_data() {
  // @@protoc_insertion_point(field_release:sea_proto.GetPiCodeReply.img_data)
  
  return img_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetPiCodeReply::set_allocated_img_data(::std::string* img_data) {
  if (img_data != NULL) {
    
  } else {
    
  }
  img_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), img_data);
  // @@protoc_insertion_point(field_set_allocated:sea_proto.GetPiCodeReply.img_data)
}

// -------------------------------------------------------------------

// GetSmsVericodeRequest

// string session_id = 1;
inline void GetSmsVericodeRequest::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetSmsVericodeRequest::session_id() const {
  // @@protoc_insertion_point(field_get:sea_proto.GetSmsVericodeRequest.session_id)
  return session_id_.GetNoArena();
}
inline void GetSmsVericodeRequest::set_session_id(const ::std::string& value) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sea_proto.GetSmsVericodeRequest.session_id)
}
#if LANG_CXX11
inline void GetSmsVericodeRequest::set_session_id(::std::string&& value) {
  
  session_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sea_proto.GetSmsVericodeRequest.session_id)
}
#endif
inline void GetSmsVericodeRequest::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sea_proto.GetSmsVericodeRequest.session_id)
}
inline void GetSmsVericodeRequest::set_session_id(const char* value, size_t size) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sea_proto.GetSmsVericodeRequest.session_id)
}
inline ::std::string* GetSmsVericodeRequest::mutable_session_id() {
  
  // @@protoc_insertion_point(field_mutable:sea_proto.GetSmsVericodeRequest.session_id)
  return session_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetSmsVericodeRequest::release_session_id() {
  // @@protoc_insertion_point(field_release:sea_proto.GetSmsVericodeRequest.session_id)
  
  return session_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetSmsVericodeRequest::set_allocated_session_id(::std::string* session_id) {
  if (session_id != NULL) {
    
  } else {
    
  }
  session_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:sea_proto.GetSmsVericodeRequest.session_id)
}

// string pic_code = 2;
inline void GetSmsVericodeRequest::clear_pic_code() {
  pic_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetSmsVericodeRequest::pic_code() const {
  // @@protoc_insertion_point(field_get:sea_proto.GetSmsVericodeRequest.pic_code)
  return pic_code_.GetNoArena();
}
inline void GetSmsVericodeRequest::set_pic_code(const ::std::string& value) {
  
  pic_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sea_proto.GetSmsVericodeRequest.pic_code)
}
#if LANG_CXX11
inline void GetSmsVericodeRequest::set_pic_code(::std::string&& value) {
  
  pic_code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sea_proto.GetSmsVericodeRequest.pic_code)
}
#endif
inline void GetSmsVericodeRequest::set_pic_code(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pic_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sea_proto.GetSmsVericodeRequest.pic_code)
}
inline void GetSmsVericodeRequest::set_pic_code(const char* value, size_t size) {
  
  pic_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sea_proto.GetSmsVericodeRequest.pic_code)
}
inline ::std::string* GetSmsVericodeRequest::mutable_pic_code() {
  
  // @@protoc_insertion_point(field_mutable:sea_proto.GetSmsVericodeRequest.pic_code)
  return pic_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetSmsVericodeRequest::release_pic_code() {
  // @@protoc_insertion_point(field_release:sea_proto.GetSmsVericodeRequest.pic_code)
  
  return pic_code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetSmsVericodeRequest::set_allocated_pic_code(::std::string* pic_code) {
  if (pic_code != NULL) {
    
  } else {
    
  }
  pic_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pic_code);
  // @@protoc_insertion_point(field_set_allocated:sea_proto.GetSmsVericodeRequest.pic_code)
}

// string phone = 3;
inline void GetSmsVericodeRequest::clear_phone() {
  phone_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetSmsVericodeRequest::phone() const {
  // @@protoc_insertion_point(field_get:sea_proto.GetSmsVericodeRequest.phone)
  return phone_.GetNoArena();
}
inline void GetSmsVericodeRequest::set_phone(const ::std::string& value) {
  
  phone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sea_proto.GetSmsVericodeRequest.phone)
}
#if LANG_CXX11
inline void GetSmsVericodeRequest::set_phone(::std::string&& value) {
  
  phone_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sea_proto.GetSmsVericodeRequest.phone)
}
#endif
inline void GetSmsVericodeRequest::set_phone(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  phone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sea_proto.GetSmsVericodeRequest.phone)
}
inline void GetSmsVericodeRequest::set_phone(const char* value, size_t size) {
  
  phone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sea_proto.GetSmsVericodeRequest.phone)
}
inline ::std::string* GetSmsVericodeRequest::mutable_phone() {
  
  // @@protoc_insertion_point(field_mutable:sea_proto.GetSmsVericodeRequest.phone)
  return phone_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetSmsVericodeRequest::release_phone() {
  // @@protoc_insertion_point(field_release:sea_proto.GetSmsVericodeRequest.phone)
  
  return phone_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetSmsVericodeRequest::set_allocated_phone(::std::string* phone) {
  if (phone != NULL) {
    
  } else {
    
  }
  phone_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), phone);
  // @@protoc_insertion_point(field_set_allocated:sea_proto.GetSmsVericodeRequest.phone)
}

// .sea_proto.ClientInfo client_info = 9;
inline bool GetSmsVericodeRequest::has_client_info() const {
  return this != internal_default_instance() && client_info_ != NULL;
}
inline const ::sea_proto::ClientInfo& GetSmsVericodeRequest::client_info() const {
  const ::sea_proto::ClientInfo* p = client_info_;
  // @@protoc_insertion_point(field_get:sea_proto.GetSmsVericodeRequest.client_info)
  return p != NULL ? *p : *reinterpret_cast<const ::sea_proto::ClientInfo*>(
      &::sea_proto::_ClientInfo_default_instance_);
}
inline ::sea_proto::ClientInfo* GetSmsVericodeRequest::release_client_info() {
  // @@protoc_insertion_point(field_release:sea_proto.GetSmsVericodeRequest.client_info)
  
  ::sea_proto::ClientInfo* temp = client_info_;
  client_info_ = NULL;
  return temp;
}
inline ::sea_proto::ClientInfo* GetSmsVericodeRequest::mutable_client_info() {
  
  if (client_info_ == NULL) {
    client_info_ = ::google::protobuf::Arena::Create< ::sea_proto::ClientInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sea_proto.GetSmsVericodeRequest.client_info)
  return client_info_;
}
inline void GetSmsVericodeRequest::set_allocated_client_info(::sea_proto::ClientInfo* client_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(client_info_);
  }
  if (client_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      client_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, client_info, submessage_arena);
    }
    
  } else {
    
  }
  client_info_ = client_info;
  // @@protoc_insertion_point(field_set_allocated:sea_proto.GetSmsVericodeRequest.client_info)
}

// -------------------------------------------------------------------

// GetSmsVericodeReply

// .sea_proto.ErrorInfo err_info = 1;
inline bool GetSmsVericodeReply::has_err_info() const {
  return this != internal_default_instance() && err_info_ != NULL;
}
inline const ::sea_proto::ErrorInfo& GetSmsVericodeReply::err_info() const {
  const ::sea_proto::ErrorInfo* p = err_info_;
  // @@protoc_insertion_point(field_get:sea_proto.GetSmsVericodeReply.err_info)
  return p != NULL ? *p : *reinterpret_cast<const ::sea_proto::ErrorInfo*>(
      &::sea_proto::_ErrorInfo_default_instance_);
}
inline ::sea_proto::ErrorInfo* GetSmsVericodeReply::release_err_info() {
  // @@protoc_insertion_point(field_release:sea_proto.GetSmsVericodeReply.err_info)
  
  ::sea_proto::ErrorInfo* temp = err_info_;
  err_info_ = NULL;
  return temp;
}
inline ::sea_proto::ErrorInfo* GetSmsVericodeReply::mutable_err_info() {
  
  if (err_info_ == NULL) {
    err_info_ = ::google::protobuf::Arena::Create< ::sea_proto::ErrorInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sea_proto.GetSmsVericodeReply.err_info)
  return err_info_;
}
inline void GetSmsVericodeReply::set_allocated_err_info(::sea_proto::ErrorInfo* err_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(err_info_);
  }
  if (err_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      err_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, err_info, submessage_arena);
    }
    
  } else {
    
  }
  err_info_ = err_info;
  // @@protoc_insertion_point(field_set_allocated:sea_proto.GetSmsVericodeReply.err_info)
}

// int32 expire_time = 2;
inline void GetSmsVericodeReply::clear_expire_time() {
  expire_time_ = 0;
}
inline ::google::protobuf::int32 GetSmsVericodeReply::expire_time() const {
  // @@protoc_insertion_point(field_get:sea_proto.GetSmsVericodeReply.expire_time)
  return expire_time_;
}
inline void GetSmsVericodeReply::set_expire_time(::google::protobuf::int32 value) {
  
  expire_time_ = value;
  // @@protoc_insertion_point(field_set:sea_proto.GetSmsVericodeReply.expire_time)
}

// -------------------------------------------------------------------

// SignupRequest

// string phone = 1;
inline void SignupRequest::clear_phone() {
  phone_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SignupRequest::phone() const {
  // @@protoc_insertion_point(field_get:sea_proto.SignupRequest.phone)
  return phone_.GetNoArena();
}
inline void SignupRequest::set_phone(const ::std::string& value) {
  
  phone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sea_proto.SignupRequest.phone)
}
#if LANG_CXX11
inline void SignupRequest::set_phone(::std::string&& value) {
  
  phone_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sea_proto.SignupRequest.phone)
}
#endif
inline void SignupRequest::set_phone(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  phone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sea_proto.SignupRequest.phone)
}
inline void SignupRequest::set_phone(const char* value, size_t size) {
  
  phone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sea_proto.SignupRequest.phone)
}
inline ::std::string* SignupRequest::mutable_phone() {
  
  // @@protoc_insertion_point(field_mutable:sea_proto.SignupRequest.phone)
  return phone_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignupRequest::release_phone() {
  // @@protoc_insertion_point(field_release:sea_proto.SignupRequest.phone)
  
  return phone_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignupRequest::set_allocated_phone(::std::string* phone) {
  if (phone != NULL) {
    
  } else {
    
  }
  phone_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), phone);
  // @@protoc_insertion_point(field_set_allocated:sea_proto.SignupRequest.phone)
}

// string session_id = 2;
inline void SignupRequest::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SignupRequest::session_id() const {
  // @@protoc_insertion_point(field_get:sea_proto.SignupRequest.session_id)
  return session_id_.GetNoArena();
}
inline void SignupRequest::set_session_id(const ::std::string& value) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sea_proto.SignupRequest.session_id)
}
#if LANG_CXX11
inline void SignupRequest::set_session_id(::std::string&& value) {
  
  session_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sea_proto.SignupRequest.session_id)
}
#endif
inline void SignupRequest::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sea_proto.SignupRequest.session_id)
}
inline void SignupRequest::set_session_id(const char* value, size_t size) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sea_proto.SignupRequest.session_id)
}
inline ::std::string* SignupRequest::mutable_session_id() {
  
  // @@protoc_insertion_point(field_mutable:sea_proto.SignupRequest.session_id)
  return session_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignupRequest::release_session_id() {
  // @@protoc_insertion_point(field_release:sea_proto.SignupRequest.session_id)
  
  return session_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignupRequest::set_allocated_session_id(::std::string* session_id) {
  if (session_id != NULL) {
    
  } else {
    
  }
  session_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:sea_proto.SignupRequest.session_id)
}

// string verify_code = 3;
inline void SignupRequest::clear_verify_code() {
  verify_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SignupRequest::verify_code() const {
  // @@protoc_insertion_point(field_get:sea_proto.SignupRequest.verify_code)
  return verify_code_.GetNoArena();
}
inline void SignupRequest::set_verify_code(const ::std::string& value) {
  
  verify_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sea_proto.SignupRequest.verify_code)
}
#if LANG_CXX11
inline void SignupRequest::set_verify_code(::std::string&& value) {
  
  verify_code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sea_proto.SignupRequest.verify_code)
}
#endif
inline void SignupRequest::set_verify_code(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  verify_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sea_proto.SignupRequest.verify_code)
}
inline void SignupRequest::set_verify_code(const char* value, size_t size) {
  
  verify_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sea_proto.SignupRequest.verify_code)
}
inline ::std::string* SignupRequest::mutable_verify_code() {
  
  // @@protoc_insertion_point(field_mutable:sea_proto.SignupRequest.verify_code)
  return verify_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignupRequest::release_verify_code() {
  // @@protoc_insertion_point(field_release:sea_proto.SignupRequest.verify_code)
  
  return verify_code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignupRequest::set_allocated_verify_code(::std::string* verify_code) {
  if (verify_code != NULL) {
    
  } else {
    
  }
  verify_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), verify_code);
  // @@protoc_insertion_point(field_set_allocated:sea_proto.SignupRequest.verify_code)
}

// string passwd = 4;
inline void SignupRequest::clear_passwd() {
  passwd_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SignupRequest::passwd() const {
  // @@protoc_insertion_point(field_get:sea_proto.SignupRequest.passwd)
  return passwd_.GetNoArena();
}
inline void SignupRequest::set_passwd(const ::std::string& value) {
  
  passwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sea_proto.SignupRequest.passwd)
}
#if LANG_CXX11
inline void SignupRequest::set_passwd(::std::string&& value) {
  
  passwd_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sea_proto.SignupRequest.passwd)
}
#endif
inline void SignupRequest::set_passwd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  passwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sea_proto.SignupRequest.passwd)
}
inline void SignupRequest::set_passwd(const char* value, size_t size) {
  
  passwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sea_proto.SignupRequest.passwd)
}
inline ::std::string* SignupRequest::mutable_passwd() {
  
  // @@protoc_insertion_point(field_mutable:sea_proto.SignupRequest.passwd)
  return passwd_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignupRequest::release_passwd() {
  // @@protoc_insertion_point(field_release:sea_proto.SignupRequest.passwd)
  
  return passwd_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignupRequest::set_allocated_passwd(::std::string* passwd) {
  if (passwd != NULL) {
    
  } else {
    
  }
  passwd_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), passwd);
  // @@protoc_insertion_point(field_set_allocated:sea_proto.SignupRequest.passwd)
}

// string name = 5;
inline void SignupRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SignupRequest::name() const {
  // @@protoc_insertion_point(field_get:sea_proto.SignupRequest.name)
  return name_.GetNoArena();
}
inline void SignupRequest::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sea_proto.SignupRequest.name)
}
#if LANG_CXX11
inline void SignupRequest::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sea_proto.SignupRequest.name)
}
#endif
inline void SignupRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sea_proto.SignupRequest.name)
}
inline void SignupRequest::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sea_proto.SignupRequest.name)
}
inline ::std::string* SignupRequest::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:sea_proto.SignupRequest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignupRequest::release_name() {
  // @@protoc_insertion_point(field_release:sea_proto.SignupRequest.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignupRequest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:sea_proto.SignupRequest.name)
}

// .sea_proto.ClientInfo client_info = 9;
inline bool SignupRequest::has_client_info() const {
  return this != internal_default_instance() && client_info_ != NULL;
}
inline const ::sea_proto::ClientInfo& SignupRequest::client_info() const {
  const ::sea_proto::ClientInfo* p = client_info_;
  // @@protoc_insertion_point(field_get:sea_proto.SignupRequest.client_info)
  return p != NULL ? *p : *reinterpret_cast<const ::sea_proto::ClientInfo*>(
      &::sea_proto::_ClientInfo_default_instance_);
}
inline ::sea_proto::ClientInfo* SignupRequest::release_client_info() {
  // @@protoc_insertion_point(field_release:sea_proto.SignupRequest.client_info)
  
  ::sea_proto::ClientInfo* temp = client_info_;
  client_info_ = NULL;
  return temp;
}
inline ::sea_proto::ClientInfo* SignupRequest::mutable_client_info() {
  
  if (client_info_ == NULL) {
    client_info_ = ::google::protobuf::Arena::Create< ::sea_proto::ClientInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sea_proto.SignupRequest.client_info)
  return client_info_;
}
inline void SignupRequest::set_allocated_client_info(::sea_proto::ClientInfo* client_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(client_info_);
  }
  if (client_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      client_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, client_info, submessage_arena);
    }
    
  } else {
    
  }
  client_info_ = client_info;
  // @@protoc_insertion_point(field_set_allocated:sea_proto.SignupRequest.client_info)
}

// -------------------------------------------------------------------

// SignupReply

// .sea_proto.ErrorInfo err_info = 1;
inline bool SignupReply::has_err_info() const {
  return this != internal_default_instance() && err_info_ != NULL;
}
inline const ::sea_proto::ErrorInfo& SignupReply::err_info() const {
  const ::sea_proto::ErrorInfo* p = err_info_;
  // @@protoc_insertion_point(field_get:sea_proto.SignupReply.err_info)
  return p != NULL ? *p : *reinterpret_cast<const ::sea_proto::ErrorInfo*>(
      &::sea_proto::_ErrorInfo_default_instance_);
}
inline ::sea_proto::ErrorInfo* SignupReply::release_err_info() {
  // @@protoc_insertion_point(field_release:sea_proto.SignupReply.err_info)
  
  ::sea_proto::ErrorInfo* temp = err_info_;
  err_info_ = NULL;
  return temp;
}
inline ::sea_proto::ErrorInfo* SignupReply::mutable_err_info() {
  
  if (err_info_ == NULL) {
    err_info_ = ::google::protobuf::Arena::Create< ::sea_proto::ErrorInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sea_proto.SignupReply.err_info)
  return err_info_;
}
inline void SignupReply::set_allocated_err_info(::sea_proto::ErrorInfo* err_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(err_info_);
  }
  if (err_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      err_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, err_info, submessage_arena);
    }
    
  } else {
    
  }
  err_info_ = err_info;
  // @@protoc_insertion_point(field_set_allocated:sea_proto.SignupReply.err_info)
}

// int64 uid = 2;
inline void SignupReply::clear_uid() {
  uid_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 SignupReply::uid() const {
  // @@protoc_insertion_point(field_get:sea_proto.SignupReply.uid)
  return uid_;
}
inline void SignupReply::set_uid(::google::protobuf::int64 value) {
  
  uid_ = value;
  // @@protoc_insertion_point(field_set:sea_proto.SignupReply.uid)
}

// -------------------------------------------------------------------

// SetUserBasicInfoRequest

// .user_proto.UserBasicInfo user_info = 1;
inline bool SetUserBasicInfoRequest::has_user_info() const {
  return this != internal_default_instance() && user_info_ != NULL;
}
inline const ::user_proto::UserBasicInfo& SetUserBasicInfoRequest::user_info() const {
  const ::user_proto::UserBasicInfo* p = user_info_;
  // @@protoc_insertion_point(field_get:sea_proto.SetUserBasicInfoRequest.user_info)
  return p != NULL ? *p : *reinterpret_cast<const ::user_proto::UserBasicInfo*>(
      &::user_proto::_UserBasicInfo_default_instance_);
}
inline ::user_proto::UserBasicInfo* SetUserBasicInfoRequest::release_user_info() {
  // @@protoc_insertion_point(field_release:sea_proto.SetUserBasicInfoRequest.user_info)
  
  ::user_proto::UserBasicInfo* temp = user_info_;
  user_info_ = NULL;
  return temp;
}
inline ::user_proto::UserBasicInfo* SetUserBasicInfoRequest::mutable_user_info() {
  
  if (user_info_ == NULL) {
    user_info_ = ::google::protobuf::Arena::Create< ::user_proto::UserBasicInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sea_proto.SetUserBasicInfoRequest.user_info)
  return user_info_;
}
inline void SetUserBasicInfoRequest::set_allocated_user_info(::user_proto::UserBasicInfo* user_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(user_info_);
  }
  if (user_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_info, submessage_arena);
    }
    
  } else {
    
  }
  user_info_ = user_info;
  // @@protoc_insertion_point(field_set_allocated:sea_proto.SetUserBasicInfoRequest.user_info)
}

// .sea_proto.ClientInfo client_info = 9;
inline bool SetUserBasicInfoRequest::has_client_info() const {
  return this != internal_default_instance() && client_info_ != NULL;
}
inline const ::sea_proto::ClientInfo& SetUserBasicInfoRequest::client_info() const {
  const ::sea_proto::ClientInfo* p = client_info_;
  // @@protoc_insertion_point(field_get:sea_proto.SetUserBasicInfoRequest.client_info)
  return p != NULL ? *p : *reinterpret_cast<const ::sea_proto::ClientInfo*>(
      &::sea_proto::_ClientInfo_default_instance_);
}
inline ::sea_proto::ClientInfo* SetUserBasicInfoRequest::release_client_info() {
  // @@protoc_insertion_point(field_release:sea_proto.SetUserBasicInfoRequest.client_info)
  
  ::sea_proto::ClientInfo* temp = client_info_;
  client_info_ = NULL;
  return temp;
}
inline ::sea_proto::ClientInfo* SetUserBasicInfoRequest::mutable_client_info() {
  
  if (client_info_ == NULL) {
    client_info_ = ::google::protobuf::Arena::Create< ::sea_proto::ClientInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sea_proto.SetUserBasicInfoRequest.client_info)
  return client_info_;
}
inline void SetUserBasicInfoRequest::set_allocated_client_info(::sea_proto::ClientInfo* client_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(client_info_);
  }
  if (client_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      client_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, client_info, submessage_arena);
    }
    
  } else {
    
  }
  client_info_ = client_info;
  // @@protoc_insertion_point(field_set_allocated:sea_proto.SetUserBasicInfoRequest.client_info)
}

// -------------------------------------------------------------------

// SetUserBasicInfoReply

// .sea_proto.ErrorInfo err_info = 1;
inline bool SetUserBasicInfoReply::has_err_info() const {
  return this != internal_default_instance() && err_info_ != NULL;
}
inline const ::sea_proto::ErrorInfo& SetUserBasicInfoReply::err_info() const {
  const ::sea_proto::ErrorInfo* p = err_info_;
  // @@protoc_insertion_point(field_get:sea_proto.SetUserBasicInfoReply.err_info)
  return p != NULL ? *p : *reinterpret_cast<const ::sea_proto::ErrorInfo*>(
      &::sea_proto::_ErrorInfo_default_instance_);
}
inline ::sea_proto::ErrorInfo* SetUserBasicInfoReply::release_err_info() {
  // @@protoc_insertion_point(field_release:sea_proto.SetUserBasicInfoReply.err_info)
  
  ::sea_proto::ErrorInfo* temp = err_info_;
  err_info_ = NULL;
  return temp;
}
inline ::sea_proto::ErrorInfo* SetUserBasicInfoReply::mutable_err_info() {
  
  if (err_info_ == NULL) {
    err_info_ = ::google::protobuf::Arena::Create< ::sea_proto::ErrorInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sea_proto.SetUserBasicInfoReply.err_info)
  return err_info_;
}
inline void SetUserBasicInfoReply::set_allocated_err_info(::sea_proto::ErrorInfo* err_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(err_info_);
  }
  if (err_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      err_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, err_info, submessage_arena);
    }
    
  } else {
    
  }
  err_info_ = err_info;
  // @@protoc_insertion_point(field_set_allocated:sea_proto.SetUserBasicInfoReply.err_info)
}

// .user_proto.UserBasicInfo user_info = 2;
inline bool SetUserBasicInfoReply::has_user_info() const {
  return this != internal_default_instance() && user_info_ != NULL;
}
inline const ::user_proto::UserBasicInfo& SetUserBasicInfoReply::user_info() const {
  const ::user_proto::UserBasicInfo* p = user_info_;
  // @@protoc_insertion_point(field_get:sea_proto.SetUserBasicInfoReply.user_info)
  return p != NULL ? *p : *reinterpret_cast<const ::user_proto::UserBasicInfo*>(
      &::user_proto::_UserBasicInfo_default_instance_);
}
inline ::user_proto::UserBasicInfo* SetUserBasicInfoReply::release_user_info() {
  // @@protoc_insertion_point(field_release:sea_proto.SetUserBasicInfoReply.user_info)
  
  ::user_proto::UserBasicInfo* temp = user_info_;
  user_info_ = NULL;
  return temp;
}
inline ::user_proto::UserBasicInfo* SetUserBasicInfoReply::mutable_user_info() {
  
  if (user_info_ == NULL) {
    user_info_ = ::google::protobuf::Arena::Create< ::user_proto::UserBasicInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sea_proto.SetUserBasicInfoReply.user_info)
  return user_info_;
}
inline void SetUserBasicInfoReply::set_allocated_user_info(::user_proto::UserBasicInfo* user_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(user_info_);
  }
  if (user_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_info, submessage_arena);
    }
    
  } else {
    
  }
  user_info_ = user_info;
  // @@protoc_insertion_point(field_set_allocated:sea_proto.SetUserBasicInfoReply.user_info)
}

// -------------------------------------------------------------------

// LoginRequest

// string phone = 1;
inline void LoginRequest::clear_phone() {
  phone_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::phone() const {
  // @@protoc_insertion_point(field_get:sea_proto.LoginRequest.phone)
  return phone_.GetNoArena();
}
inline void LoginRequest::set_phone(const ::std::string& value) {
  
  phone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sea_proto.LoginRequest.phone)
}
#if LANG_CXX11
inline void LoginRequest::set_phone(::std::string&& value) {
  
  phone_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sea_proto.LoginRequest.phone)
}
#endif
inline void LoginRequest::set_phone(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  phone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sea_proto.LoginRequest.phone)
}
inline void LoginRequest::set_phone(const char* value, size_t size) {
  
  phone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sea_proto.LoginRequest.phone)
}
inline ::std::string* LoginRequest::mutable_phone() {
  
  // @@protoc_insertion_point(field_mutable:sea_proto.LoginRequest.phone)
  return phone_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_phone() {
  // @@protoc_insertion_point(field_release:sea_proto.LoginRequest.phone)
  
  return phone_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_phone(::std::string* phone) {
  if (phone != NULL) {
    
  } else {
    
  }
  phone_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), phone);
  // @@protoc_insertion_point(field_set_allocated:sea_proto.LoginRequest.phone)
}

// string passwd = 2;
inline void LoginRequest::clear_passwd() {
  passwd_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::passwd() const {
  // @@protoc_insertion_point(field_get:sea_proto.LoginRequest.passwd)
  return passwd_.GetNoArena();
}
inline void LoginRequest::set_passwd(const ::std::string& value) {
  
  passwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sea_proto.LoginRequest.passwd)
}
#if LANG_CXX11
inline void LoginRequest::set_passwd(::std::string&& value) {
  
  passwd_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sea_proto.LoginRequest.passwd)
}
#endif
inline void LoginRequest::set_passwd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  passwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sea_proto.LoginRequest.passwd)
}
inline void LoginRequest::set_passwd(const char* value, size_t size) {
  
  passwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sea_proto.LoginRequest.passwd)
}
inline ::std::string* LoginRequest::mutable_passwd() {
  
  // @@protoc_insertion_point(field_mutable:sea_proto.LoginRequest.passwd)
  return passwd_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_passwd() {
  // @@protoc_insertion_point(field_release:sea_proto.LoginRequest.passwd)
  
  return passwd_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_passwd(::std::string* passwd) {
  if (passwd != NULL) {
    
  } else {
    
  }
  passwd_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), passwd);
  // @@protoc_insertion_point(field_set_allocated:sea_proto.LoginRequest.passwd)
}

// string openid = 3;
inline void LoginRequest::clear_openid() {
  openid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::openid() const {
  // @@protoc_insertion_point(field_get:sea_proto.LoginRequest.openid)
  return openid_.GetNoArena();
}
inline void LoginRequest::set_openid(const ::std::string& value) {
  
  openid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sea_proto.LoginRequest.openid)
}
#if LANG_CXX11
inline void LoginRequest::set_openid(::std::string&& value) {
  
  openid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sea_proto.LoginRequest.openid)
}
#endif
inline void LoginRequest::set_openid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  openid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sea_proto.LoginRequest.openid)
}
inline void LoginRequest::set_openid(const char* value, size_t size) {
  
  openid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sea_proto.LoginRequest.openid)
}
inline ::std::string* LoginRequest::mutable_openid() {
  
  // @@protoc_insertion_point(field_mutable:sea_proto.LoginRequest.openid)
  return openid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_openid() {
  // @@protoc_insertion_point(field_release:sea_proto.LoginRequest.openid)
  
  return openid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_openid(::std::string* openid) {
  if (openid != NULL) {
    
  } else {
    
  }
  openid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), openid);
  // @@protoc_insertion_point(field_set_allocated:sea_proto.LoginRequest.openid)
}

// string openid_sig = 4;
inline void LoginRequest::clear_openid_sig() {
  openid_sig_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::openid_sig() const {
  // @@protoc_insertion_point(field_get:sea_proto.LoginRequest.openid_sig)
  return openid_sig_.GetNoArena();
}
inline void LoginRequest::set_openid_sig(const ::std::string& value) {
  
  openid_sig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sea_proto.LoginRequest.openid_sig)
}
#if LANG_CXX11
inline void LoginRequest::set_openid_sig(::std::string&& value) {
  
  openid_sig_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sea_proto.LoginRequest.openid_sig)
}
#endif
inline void LoginRequest::set_openid_sig(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  openid_sig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sea_proto.LoginRequest.openid_sig)
}
inline void LoginRequest::set_openid_sig(const char* value, size_t size) {
  
  openid_sig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sea_proto.LoginRequest.openid_sig)
}
inline ::std::string* LoginRequest::mutable_openid_sig() {
  
  // @@protoc_insertion_point(field_mutable:sea_proto.LoginRequest.openid_sig)
  return openid_sig_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_openid_sig() {
  // @@protoc_insertion_point(field_release:sea_proto.LoginRequest.openid_sig)
  
  return openid_sig_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_openid_sig(::std::string* openid_sig) {
  if (openid_sig != NULL) {
    
  } else {
    
  }
  openid_sig_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), openid_sig);
  // @@protoc_insertion_point(field_set_allocated:sea_proto.LoginRequest.openid_sig)
}

// .sea_proto.ClientInfo client_info = 9;
inline bool LoginRequest::has_client_info() const {
  return this != internal_default_instance() && client_info_ != NULL;
}
inline const ::sea_proto::ClientInfo& LoginRequest::client_info() const {
  const ::sea_proto::ClientInfo* p = client_info_;
  // @@protoc_insertion_point(field_get:sea_proto.LoginRequest.client_info)
  return p != NULL ? *p : *reinterpret_cast<const ::sea_proto::ClientInfo*>(
      &::sea_proto::_ClientInfo_default_instance_);
}
inline ::sea_proto::ClientInfo* LoginRequest::release_client_info() {
  // @@protoc_insertion_point(field_release:sea_proto.LoginRequest.client_info)
  
  ::sea_proto::ClientInfo* temp = client_info_;
  client_info_ = NULL;
  return temp;
}
inline ::sea_proto::ClientInfo* LoginRequest::mutable_client_info() {
  
  if (client_info_ == NULL) {
    client_info_ = ::google::protobuf::Arena::Create< ::sea_proto::ClientInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sea_proto.LoginRequest.client_info)
  return client_info_;
}
inline void LoginRequest::set_allocated_client_info(::sea_proto::ClientInfo* client_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(client_info_);
  }
  if (client_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      client_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, client_info, submessage_arena);
    }
    
  } else {
    
  }
  client_info_ = client_info;
  // @@protoc_insertion_point(field_set_allocated:sea_proto.LoginRequest.client_info)
}

// -------------------------------------------------------------------

// LoginReply

// .sea_proto.ErrorInfo err_info = 1;
inline bool LoginReply::has_err_info() const {
  return this != internal_default_instance() && err_info_ != NULL;
}
inline const ::sea_proto::ErrorInfo& LoginReply::err_info() const {
  const ::sea_proto::ErrorInfo* p = err_info_;
  // @@protoc_insertion_point(field_get:sea_proto.LoginReply.err_info)
  return p != NULL ? *p : *reinterpret_cast<const ::sea_proto::ErrorInfo*>(
      &::sea_proto::_ErrorInfo_default_instance_);
}
inline ::sea_proto::ErrorInfo* LoginReply::release_err_info() {
  // @@protoc_insertion_point(field_release:sea_proto.LoginReply.err_info)
  
  ::sea_proto::ErrorInfo* temp = err_info_;
  err_info_ = NULL;
  return temp;
}
inline ::sea_proto::ErrorInfo* LoginReply::mutable_err_info() {
  
  if (err_info_ == NULL) {
    err_info_ = ::google::protobuf::Arena::Create< ::sea_proto::ErrorInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sea_proto.LoginReply.err_info)
  return err_info_;
}
inline void LoginReply::set_allocated_err_info(::sea_proto::ErrorInfo* err_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(err_info_);
  }
  if (err_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      err_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, err_info, submessage_arena);
    }
    
  } else {
    
  }
  err_info_ = err_info;
  // @@protoc_insertion_point(field_set_allocated:sea_proto.LoginReply.err_info)
}

// string session = 2;
inline void LoginReply::clear_session() {
  session_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginReply::session() const {
  // @@protoc_insertion_point(field_get:sea_proto.LoginReply.session)
  return session_.GetNoArena();
}
inline void LoginReply::set_session(const ::std::string& value) {
  
  session_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sea_proto.LoginReply.session)
}
#if LANG_CXX11
inline void LoginReply::set_session(::std::string&& value) {
  
  session_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sea_proto.LoginReply.session)
}
#endif
inline void LoginReply::set_session(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  session_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sea_proto.LoginReply.session)
}
inline void LoginReply::set_session(const char* value, size_t size) {
  
  session_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sea_proto.LoginReply.session)
}
inline ::std::string* LoginReply::mutable_session() {
  
  // @@protoc_insertion_point(field_mutable:sea_proto.LoginReply.session)
  return session_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginReply::release_session() {
  // @@protoc_insertion_point(field_release:sea_proto.LoginReply.session)
  
  return session_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginReply::set_allocated_session(::std::string* session) {
  if (session != NULL) {
    
  } else {
    
  }
  session_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session);
  // @@protoc_insertion_point(field_set_allocated:sea_proto.LoginReply.session)
}

// .user_proto.UserBasicInfo user_info = 9;
inline bool LoginReply::has_user_info() const {
  return this != internal_default_instance() && user_info_ != NULL;
}
inline const ::user_proto::UserBasicInfo& LoginReply::user_info() const {
  const ::user_proto::UserBasicInfo* p = user_info_;
  // @@protoc_insertion_point(field_get:sea_proto.LoginReply.user_info)
  return p != NULL ? *p : *reinterpret_cast<const ::user_proto::UserBasicInfo*>(
      &::user_proto::_UserBasicInfo_default_instance_);
}
inline ::user_proto::UserBasicInfo* LoginReply::release_user_info() {
  // @@protoc_insertion_point(field_release:sea_proto.LoginReply.user_info)
  
  ::user_proto::UserBasicInfo* temp = user_info_;
  user_info_ = NULL;
  return temp;
}
inline ::user_proto::UserBasicInfo* LoginReply::mutable_user_info() {
  
  if (user_info_ == NULL) {
    user_info_ = ::google::protobuf::Arena::Create< ::user_proto::UserBasicInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sea_proto.LoginReply.user_info)
  return user_info_;
}
inline void LoginReply::set_allocated_user_info(::user_proto::UserBasicInfo* user_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(user_info_);
  }
  if (user_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      user_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_info, submessage_arena);
    }
    
  } else {
    
  }
  user_info_ = user_info;
  // @@protoc_insertion_point(field_set_allocated:sea_proto.LoginReply.user_info)
}

// -------------------------------------------------------------------

// LogoutRequest

// .sea_proto.ClientInfo client_info = 1;
inline bool LogoutRequest::has_client_info() const {
  return this != internal_default_instance() && client_info_ != NULL;
}
inline const ::sea_proto::ClientInfo& LogoutRequest::client_info() const {
  const ::sea_proto::ClientInfo* p = client_info_;
  // @@protoc_insertion_point(field_get:sea_proto.LogoutRequest.client_info)
  return p != NULL ? *p : *reinterpret_cast<const ::sea_proto::ClientInfo*>(
      &::sea_proto::_ClientInfo_default_instance_);
}
inline ::sea_proto::ClientInfo* LogoutRequest::release_client_info() {
  // @@protoc_insertion_point(field_release:sea_proto.LogoutRequest.client_info)
  
  ::sea_proto::ClientInfo* temp = client_info_;
  client_info_ = NULL;
  return temp;
}
inline ::sea_proto::ClientInfo* LogoutRequest::mutable_client_info() {
  
  if (client_info_ == NULL) {
    client_info_ = ::google::protobuf::Arena::Create< ::sea_proto::ClientInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sea_proto.LogoutRequest.client_info)
  return client_info_;
}
inline void LogoutRequest::set_allocated_client_info(::sea_proto::ClientInfo* client_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(client_info_);
  }
  if (client_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      client_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, client_info, submessage_arena);
    }
    
  } else {
    
  }
  client_info_ = client_info;
  // @@protoc_insertion_point(field_set_allocated:sea_proto.LogoutRequest.client_info)
}

// -------------------------------------------------------------------

// PingRequest

// .sea_proto.ClientInfo client_info = 1;
inline bool PingRequest::has_client_info() const {
  return this != internal_default_instance() && client_info_ != NULL;
}
inline const ::sea_proto::ClientInfo& PingRequest::client_info() const {
  const ::sea_proto::ClientInfo* p = client_info_;
  // @@protoc_insertion_point(field_get:sea_proto.PingRequest.client_info)
  return p != NULL ? *p : *reinterpret_cast<const ::sea_proto::ClientInfo*>(
      &::sea_proto::_ClientInfo_default_instance_);
}
inline ::sea_proto::ClientInfo* PingRequest::release_client_info() {
  // @@protoc_insertion_point(field_release:sea_proto.PingRequest.client_info)
  
  ::sea_proto::ClientInfo* temp = client_info_;
  client_info_ = NULL;
  return temp;
}
inline ::sea_proto::ClientInfo* PingRequest::mutable_client_info() {
  
  if (client_info_ == NULL) {
    client_info_ = ::google::protobuf::Arena::Create< ::sea_proto::ClientInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sea_proto.PingRequest.client_info)
  return client_info_;
}
inline void PingRequest::set_allocated_client_info(::sea_proto::ClientInfo* client_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(client_info_);
  }
  if (client_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      client_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, client_info, submessage_arena);
    }
    
  } else {
    
  }
  client_info_ = client_info;
  // @@protoc_insertion_point(field_set_allocated:sea_proto.PingRequest.client_info)
}

// -------------------------------------------------------------------

// PingReply

// .sea_proto.ErrorInfo err_info = 1;
inline bool PingReply::has_err_info() const {
  return this != internal_default_instance() && err_info_ != NULL;
}
inline const ::sea_proto::ErrorInfo& PingReply::err_info() const {
  const ::sea_proto::ErrorInfo* p = err_info_;
  // @@protoc_insertion_point(field_get:sea_proto.PingReply.err_info)
  return p != NULL ? *p : *reinterpret_cast<const ::sea_proto::ErrorInfo*>(
      &::sea_proto::_ErrorInfo_default_instance_);
}
inline ::sea_proto::ErrorInfo* PingReply::release_err_info() {
  // @@protoc_insertion_point(field_release:sea_proto.PingReply.err_info)
  
  ::sea_proto::ErrorInfo* temp = err_info_;
  err_info_ = NULL;
  return temp;
}
inline ::sea_proto::ErrorInfo* PingReply::mutable_err_info() {
  
  if (err_info_ == NULL) {
    err_info_ = ::google::protobuf::Arena::Create< ::sea_proto::ErrorInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sea_proto.PingReply.err_info)
  return err_info_;
}
inline void PingReply::set_allocated_err_info(::sea_proto::ErrorInfo* err_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(err_info_);
  }
  if (err_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      err_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, err_info, submessage_arena);
    }
    
  } else {
    
  }
  err_info_ = err_info;
  // @@protoc_insertion_point(field_set_allocated:sea_proto.PingReply.err_info)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sea_proto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_sea_2eproto_INCLUDED
